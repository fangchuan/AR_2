/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.22                          *
*        Compiled Jul  4 2013, 15:16:01                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

#include "Window_TreeView.h"
#include "includes.h"
#include "Window_1_1.h"

/*********************************************************************
*
*       Global data
*
**********************************************************************
*/


extern  FIL        file;
extern  FRESULT  result;
extern  UINT         bw;	
//the name of program
extern char program_name[10];
/*********************************************************************
*
*       Global data
*
**********************************************************************
*/
WM_HWIN hTree;

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0       (GUI_ID_USER + 0x00)
#define ID_TREEVIEW_FILE  (GUI_ID_USER + 0x02)
#define ID_TEXT_EXPLAN    (GUI_ID_USER + 0x03)
#define ID_BUTTON_BACK    (GUI_ID_USER + 0x04)

#define FILE_NAME_LEN 	100							//文件名长度，如果检测到文件名超过50 则丢弃这个文件 
#define PATH_LEN		    50              //路径长度
#define FILE_LIST_PATH 			"0:/FILELIST.TXT"	//文件记录列表文件的目录
#define _DF1S        0x80
/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
//static uint16_t *buffer=0;
//static char *txtBuffer=0;
static char* record_file=0;

static const char *StringHZ[] = {
	"\xe8\xaf\xb7\xe9\x80\x89\xe6\x8b\xa9\xe4\xb8\x80\xe4\xb8\xaa\xe7\xa8\x8b\xe5\xba\x8f...",//0:请选择一个程序
	"\xe8\xbf\x94\xe5\x9b\x9e","\xe4\xb8\xbb\xe7\xa8\x8b\xe5\xba\x8f",//1:返回   2:主程序
};

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 240, 320, 0, 0x0, 0 },
  { TREEVIEW_CreateIndirect, "Treeview", ID_TREEVIEW_FILE, 0, 0, 240, 193, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Text", ID_TEXT_EXPLAN, 60, 240, 100, 20, 0, 0x0, 0 },
	{BUTTON_CreateIndirect,"BACK", ID_BUTTON_BACK,180, 300, 60,  20, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
//将汉字的Unicode码转换成UTF8编码的字符串
//static void gbk2utf8(const char *src, char *str,uint32_t maxnum)
//{
//	uint32_t j=0,k=0;
//	uint16_t gbkdata=0;
//	uint16_t UCbuffer[50]={0};
//	for(j=0,k=0;(j<maxnum)&&src[j]!='\0';k++)
//	{
//		if((uint8_t)src[j]>0x80)
//		{
//			gbkdata=src[j+1]+src[j]*256;
//			UCbuffer[k]=ff_convert(gbkdata,1);
//			j+=2;
//		}
//		else
//		{
//			UCbuffer[k]=0x00ff&src[j];
//			j+=1;
//		}
//	}
//	UCbuffer[k]='\0';
//	GUI_UC_ConvertUC2UTF8(UCbuffer,2*k+2,str,k*3);
//}

//将文本文件转换成UTF8编码的字符串txtbuffer
//static uint8_t  txt2buffer(const char * sFilename) 
//{
//	OS_ERR      	err;
//	uint32_t j=0,k=0;
//	uint16_t gbkdata=0;
//	buffer = (uint16_t *)(0x680c0000);//将存放汉字unicode码的buffer指向EXTERN_SRAM的最后200K
//	txtBuffer = (char *)(0x680c0000+1024*50*2);//将存放文件内容的txtbuffer指向0x680d9000
//	OSSchedLock(&err);
//	
//	result = f_open(&file, sFilename, FA_READ);
//	if (result != FR_OK)
//	{
//		OSSchedUnlock(&err);
//		return 0;
//	}
//	//printf("filesize=%d\n",file.fsize);
//	if(file.fsize>=1024*50*2)
//	{
//		printf("Note read fail!!!\n");
//		OSSchedUnlock(&err);
//		return 0;
//  }
//	result = f_read(&file, txtBuffer, file.fsize, &bw);
//	if (result != FR_OK)
//  {
//		OSSchedUnlock(&err);
//		return 0;
//  }
//	//将文本内容转换成相应的Unicode码存放到buffer中
//	for(j=0,k=0;(j<file.fsize)&&txtBuffer[j]!='\0';k++)
//	{
//		if((uint8_t)txtBuffer[j]>0x80)
//		{
//			gbkdata=txtBuffer[j+1]+txtBuffer[j]*256;
//			buffer[k]=ff_convert(gbkdata,1);
//			j+=2;
//		}
//		else
//		{
//			buffer[k]=0x00ff&txtBuffer[j];
//			j+=1;
//		}
//	}
//	buffer[k]='\0';		
//	GUI_UC_ConvertUC2UTF8(buffer,2*k+2,txtBuffer,k*3);
//	f_close(&file);
//	OSSchedUnlock(&err);
//	return 1;	
//}


/**
  * @brief  OpenFileProcess打开文件	 
	*					
  * @param  none
  * @retval none
  */
static void OpenFileProcess(int sel_num, char* record_file)
{
	char                     openfile[FILE_NAME_LEN]={0};
	_Listptr   p = (_Listptr)malloc(sizeof(_Instructor));
	
	result = f_open (&file, FILE_LIST_PATH, FA_READ|FA_OPEN_EXISTING); //打开索引文件
	if(result != FR_OK)
      return ;
	result = f_lseek (&file, sel_num*FILE_NAME_LEN);
	if(result != FR_OK)
      return ;
	result = f_read (&file, openfile, FILE_NAME_LEN, &bw);//从filelist文件中找到被选择的那个文件名openfile	
	if(result != FR_OK)
      return ;
	//printf("\nfileItem=:%s",openfile);
	f_close (&file);
	
	f_open(&file, openfile, FA_READ | FA_OPEN_EXISTING);
	if(result != FR_OK)
		return ;
	if(!p)
		return ;
	else{
				u16      NumBytesPerList = 56;
				do{
						result = f_read(&file,p, NumBytesPerList, &bw);
						if(result != FR_OK)
							return ;
						Add_Node(p->index , p->_flag ,p->EditContent );
				}while(p->next); //链表尾结点处的next指针为空，表示最后一个结点，不用再往后读了。
				free(p);
	}
	strcpy(program_name,openfile);//将要打开的程序文件名赋给program_name
//		txt2buffer(openfile);//将openfile文件的内容转换到UTF8编码的txtbuffer字符串中
	
}
/**
  * @brief  scan_files 递归扫描flash内的文件
  * @param  path:初始扫描路径 file_name：指向用来存储文件名的一段空间 hFile:用于记录文件路径的文件指针 hTree 目录树 hNode 目录结点
	*					hTree == NULL &&	hNode == NULL 的话，不创建目录树			
  * @retval result:文件系统的返回值
  */
static FRESULT scan_files (char* path,char* file_name,FIL *hFile,WM_HWIN hTree, TREEVIEW_ITEM_Handle hNode,int *fileNum) 
{ 
		
    FRESULT        res; 		          //部分在递归过程被修改的变量，不用全局变量	
    FILINFO        fno; 
		uint32_t    rw_num;			//已读或已写的字节数
    DIR dir; 
    int i; 
    char *fn; 	
		TREEVIEW_ITEM_Handle hItem=0;

	
#if _USE_LFN      
    static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1]; 	//长文件名支持
    fno.lfname = lfn; 
    fno.lfsize = sizeof(lfn); 
#endif 

    res = f_opendir(&dir, path);                            //打开目录
    if (res == FR_OK) 
		{ 
        i = strlen(path); 
        for (;;) 
				{ 
            res = f_readdir(&dir, &fno); 										//读取目录下的内容
            if (res != FR_OK || fno.fname[0] == 0) break; 	//为空时表示所有项目读取完毕，跳出
#if _USE_LFN 
            fn = *fno.lfname ? fno.lfname : fno.fname; 
#else 
            fn = fno.fname; 
#endif 
            if (*fn == '.') continue; //点表示当前目录，跳过			
            if (fno.fattrib & AM_DIR) //目录，递归读取
						{ 																							
							
							if(hTree != NULL &&	hNode != NULL)
							{
								hItem = TREEVIEW_ITEM_Create(TREEVIEW_ITEM_TYPE_NODE,fn,0);
								TREEVIEW_AttachItem(hTree,hItem,hNode,TREEVIEW_INSERT_FIRST_CHILD);		//把结点加入到目录树中
							}
											
							sprintf(&path[i], "/%s", fn); 							//合成完整目录名
							res = scan_files(path,file_name,hFile,hTree,hItem,fileNum);		//递归遍历 
							if (res != FR_OK) 
													break; 																		//打开失败，跳出循环
							path[i] = 0; 
            } 
						else 																														//是文件
						{ 				
							/* 根据要求是否创建目录树 */
							if(hTree != NULL &&	hNode != NULL)																			//创建目录树
							{
								hItem = TREEVIEW_ITEM_Create(TREEVIEW_ITEM_TYPE_LEAF,fn,0);
								TREEVIEW_AttachItem(hTree,hItem,hNode,TREEVIEW_INSERT_FIRST_CHILD);		//把树叶添加到目录树
						
								if(strcmp(fn, "FILELIST.TXT") != 0)
								{
									if (strlen(path)+strlen(fn)<FILE_NAME_LEN)
									{
										sprintf(file_name, "%s/%s", path,fn); 	
										
										//存储文件名到filelist(含路径)										
										res = f_lseek (hFile, hItem*FILE_NAME_LEN);  
										res = f_write (hFile, file_name, FILE_NAME_LEN, &rw_num);	
										//printf("\nfileItem=%ld:%s",hItem,file_name);
									}		
								}								
							}
						}//else
        } //for
    } 

    return res; 
} 


/**
  * @brief  Fill_FileList处理非递归过程，然后调用递归函数scan_files扫描目录
	*					
  * @param  path:初始扫描路径
  * @retval none
  */
void Fill_FileList(char* path,char* record_file,WM_HWIN hTree, TREEVIEW_ITEM_Handle hNode,int *p)
{
	char  p_path[PATH_LEN]={0};									//目录名 指针
	char  file_name[FILE_NAME_LEN]={0};								//用于存储的目录文件名，
//	result = f_unlink(record_file);//暂时删除旧的目录， 增加自建目录
	result = f_open (&file, record_file, FA_READ|FA_WRITE| FA_OPEN_ALWAYS ); //打开创建索引文件
  if(result != FR_OK)
      return ;
	strcpy(p_path,path);						//复制目录名到指针
	
	result = scan_files(p_path,file_name,&file,hTree,hNode,p);			//递归扫描文件		
	
	f_close (&file);					//关闭索引文件	

}

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  TREEVIEW_ITEM_Handle hNode;			//结点句柄
  TREEVIEW_ITEM_INFO ItemInfo;
  WM_HWIN                hItem;
  int                    NCode;
  int                    Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Window'
    //
    hItem = pMsg->hWin;
    WINDOW_SetBkColor(hItem, GUI_LIGHTBLUE);
    //
    // Initialization of 'Treeview'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TREEVIEW_FILE);
		TREEVIEW_SetFont(hItem, &GUI_FontSongTi12);
		TREEVIEW_SetDefaultFont(&GUI_FontSongTi12);
		TREEVIEW_SetAutoScrollH(hItem,1);
		TREEVIEW_SetAutoScrollV(hItem,1);
		TREEVIEW_SetSelMode(hItem, TREEVIEW_SELMODE_ROW);
		hNode = TREEVIEW_InsertItem(hItem, TREEVIEW_ITEM_TYPE_NODE, 0, 0, StringHZ[2]);
		//更新filelist文件
		Fill_FileList("0:", record_file, hItem ,hNode,(void*)0);
		TREEVIEW_ITEM_Expand(hNode);//展开指定结点
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_EXPLAN);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetTextColor(hItem, GUI_RED);
    TEXT_SetFont(hItem, &GUI_FontSongTi12);
		TEXT_SetText(hItem,StringHZ[0]);
		//
		//Initializztion of Button
		//
		hItem = WM_GetDialogItem(pMsg->hWin ,ID_BUTTON_BACK);
		BUTTON_SetFont(hItem, &GUI_FontSongTi12);
		BUTTON_SetText(hItem, StringHZ[1]);
		
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_TREEVIEW_FILE: // Notifications sent by 'Treeview'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
						/* 查看选中了哪个项目 */
						hNode = TREEVIEW_GetSel(pMsg->hWinSrc);						
						/* 获取该项目的信息 */
						TREEVIEW_ITEM_GetInfo(hNode,&ItemInfo);
				
						if(ItemInfo.IsNode == 0)        //点击的是目录树的叶子（即文件）
						{
							OpenFileProcess(hNode,record_file);
						}
        break;
      case WM_NOTIFICATION_MOVED_OUT:
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        break;

      }
      break;
		case ID_BUTTON_BACK:
					switch(NCode)
					{
						case WM_NOTIFICATION_CLICKED:
							break;
						case WM_NOTIFICATION_RELEASED:
									GUI_EndDialog(pMsg->hWin ,0);
//									WM_HideWindow(hTree);
							break;
					}
				break;
    }
    break;
	case WM_PAINT:
		break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateWindow_TreeView(void);
WM_HWIN CreateWindow_TreeView(void) {

	record_file = FILE_LIST_PATH;
  hTree = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hTree;
}

//写入用户保存的文本，都是叶子项目，没有结点项目
void WriteFileProcess(void)
{
		_Listptr  p = Ins_List_Head -> next;
		int      ListLength = GetListLength();
		int      NumBytesPerList = 56;
		char     path[PATH_LEN] = {0};
	
//		result = f_open (&file, FILE_LIST_PATH, FA_WRITE|FA_OPEN_EXISTING); //打开索引文件
//		if(result != FR_OK)
//      return ;
//		result = f_lseek (&file, file.fsize * FILE_NAME_LEN);
//		if(result != FR_OK)
//      return ;
		sprintf(path,"%s/%s","0:",program_name);
//		result = f_write(&file,FILE_LIST_PATH,sizeof(path),&bw);//在filelist中写入新保存的程序文件名
//		if(result != FR_OK)
//			return ;
		result = f_open(&file,path,FA_WRITE | FA_CREATE_ALWAYS);//新建一个程序文件，如果该程序文件已存在，则覆盖原文件
		if(result != FR_OK)
			return ;
		while(ListLength > 0)
		{
			if(p)
			{	
				result = f_write(&file, p, NumBytesPerList, &bw);
				if(result != FR_OK)
					return ;
				p = p -> next;
			}
			ListLength --;
		}
		f_close(&file);
}

/*************************** End of file ****************************/
